#
# Autogenerated by Thrift Compiler (0.22.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec
from uuid import UUID

import sys

from thrift.transport import TTransport
all_structs = []


class ClassID(object):
    Unknown = -1
    NoTube = 0
    NoHatTube = 1
    HatTube = 2

    _VALUES_TO_NAMES = {
        -1: "Unknown",
        0: "NoTube",
        1: "NoHatTube",
        2: "HatTube",
    }

    _NAMES_TO_VALUES = {
        "Unknown": -1,
        "NoTube": 0,
        "NoHatTube": 1,
        "HatTube": 2,
    }


class TaskState(object):
    NoneState = 0
    Issued = 1
    Identifying = 2
    Finished = 3

    _VALUES_TO_NAMES = {
        0: "NoneState",
        1: "Issued",
        2: "Identifying",
        3: "Finished",
    }

    _NAMES_TO_VALUES = {
        "NoneState": 0,
        "Issued": 1,
        "Identifying": 2,
        "Finished": 3,
    }


class TaskResult(object):
    Success = 0
    CameraFault = 1
    UnknownFault = 3

    _VALUES_TO_NAMES = {
        0: "Success",
        1: "CameraFault",
        3: "UnknownFault",
    }

    _NAMES_TO_VALUES = {
        "Success": 0,
        "CameraFault": 1,
        "UnknownFault": 3,
    }


class RunningState(object):
    Ready = 0
    Reseting = 1
    Stop = 2
    Fault = 3

    _VALUES_TO_NAMES = {
        0: "Ready",
        1: "Reseting",
        2: "Stop",
        3: "Fault",
    }

    _NAMES_TO_VALUES = {
        "Ready": 0,
        "Reseting": 1,
        "Stop": 2,
        "Fault": 3,
    }


class Bbox(object):
    """
    Attributes:
     - x
     - y
     - w
     - h

    """
    thrift_spec = None


    def __init__(self, x = 0, y = 0, w = 0, h = 0,):
        self.x = x
        self.y = y
        self.w = w
        self.h = h

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.x = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.y = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.w = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.h = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Bbox')
        if self.x is not None:
            oprot.writeFieldBegin('x', TType.I32, 1)
            oprot.writeI32(self.x)
            oprot.writeFieldEnd()
        if self.y is not None:
            oprot.writeFieldBegin('y', TType.I32, 2)
            oprot.writeI32(self.y)
            oprot.writeFieldEnd()
        if self.w is not None:
            oprot.writeFieldBegin('w', TType.I32, 3)
            oprot.writeI32(self.w)
            oprot.writeFieldEnd()
        if self.h is not None:
            oprot.writeFieldBegin('h', TType.I32, 4)
            oprot.writeI32(self.h)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DetectionC(object):
    """
    Attributes:
     - class_id
     - cla_score
     - box

    """
    thrift_spec = None


    def __init__(self, class_id =     -1, cla_score = 0.0000000000000000, box = None,):
        self.class_id = class_id
        self.cla_score = cla_score
        self.box = box

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.class_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.cla_score = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.box = Bbox()
                    self.box.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DetectionC')
        if self.class_id is not None:
            oprot.writeFieldBegin('class_id', TType.I32, 1)
            oprot.writeI32(self.class_id)
            oprot.writeFieldEnd()
        if self.cla_score is not None:
            oprot.writeFieldBegin('cla_score', TType.DOUBLE, 2)
            oprot.writeDouble(self.cla_score)
            oprot.writeFieldEnd()
        if self.box is not None:
            oprot.writeFieldBegin('box', TType.STRUCT, 3)
            self.box.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ImageInfo(object):
    """
    Attributes:
     - width
     - height
     - data

    """
    thrift_spec = None


    def __init__(self, width = None, height = None, data = None,):
        self.width = width
        self.height = height
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.width = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.height = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ImageInfo')
        if self.width is not None:
            oprot.writeFieldBegin('width', TType.I32, 1)
            oprot.writeI32(self.width)
            oprot.writeFieldEnd()
        if self.height is not None:
            oprot.writeFieldBegin('height', TType.I32, 2)
            oprot.writeI32(self.height)
            oprot.writeFieldEnd()
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRING, 3)
            oprot.writeBinary(self.data)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HolesRecgInfo(object):
    """
    Attributes:
     - holes
     - image
     - imageMark

    """
    thrift_spec = None


    def __init__(self, holes = None, image = None, imageMark = None,):
        self.holes = holes
        self.image = image
        self.imageMark = imageMark

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.holes = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = DetectionC()
                        _elem5.read(iprot)
                        self.holes.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.image = ImageInfo()
                    self.image.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.imageMark = ImageInfo()
                    self.imageMark.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('HolesRecgInfo')
        if self.holes is not None:
            oprot.writeFieldBegin('holes', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.holes))
            for iter6 in self.holes:
                iter6.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.image is not None:
            oprot.writeFieldBegin('image', TType.STRUCT, 2)
            self.image.write(oprot)
            oprot.writeFieldEnd()
        if self.imageMark is not None:
            oprot.writeFieldBegin('imageMark', TType.STRUCT, 3)
            self.imageMark.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TaskInfo(object):
    """
    Attributes:
     - taskId
     - state
     - result
     - info

    """
    thrift_spec = None


    def __init__(self, taskId = None, state = None, result = None, info = None,):
        self.taskId = taskId
        self.state = state
        self.result = result
        self.info = info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.taskId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.state = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.result = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.info = HolesRecgInfo()
                    self.info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TaskInfo')
        if self.taskId is not None:
            oprot.writeFieldBegin('taskId', TType.STRING, 1)
            oprot.writeString(self.taskId.encode('utf-8') if sys.version_info[0] == 2 else self.taskId)
            oprot.writeFieldEnd()
        if self.state is not None:
            oprot.writeFieldBegin('state', TType.I32, 2)
            oprot.writeI32(self.state)
            oprot.writeFieldEnd()
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.I32, 3)
            oprot.writeI32(self.result)
            oprot.writeFieldEnd()
        if self.info is not None:
            oprot.writeFieldBegin('info', TType.STRUCT, 4)
            self.info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DeviceInfo(object):
    """
    Attributes:
     - runningState

    """
    thrift_spec = None


    def __init__(self, runningState = None,):
        self.runningState = runningState

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.runningState = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DeviceInfo')
        if self.runningState is not None:
            oprot.writeFieldBegin('runningState', TType.I32, 1)
            oprot.writeI32(self.runningState)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Bbox)
Bbox.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'x', None, 0, ),  # 1
    (2, TType.I32, 'y', None, 0, ),  # 2
    (3, TType.I32, 'w', None, 0, ),  # 3
    (4, TType.I32, 'h', None, 0, ),  # 4
)
all_structs.append(DetectionC)
DetectionC.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'class_id', None,     -1, ),  # 1
    (2, TType.DOUBLE, 'cla_score', None, 0.0000000000000000, ),  # 2
    (3, TType.STRUCT, 'box', [Bbox, None], None, ),  # 3
)
all_structs.append(ImageInfo)
ImageInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'width', None, None, ),  # 1
    (2, TType.I32, 'height', None, None, ),  # 2
    (3, TType.STRING, 'data', 'BINARY', None, ),  # 3
)
all_structs.append(HolesRecgInfo)
HolesRecgInfo.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'holes', (TType.STRUCT, [DetectionC, None], False), None, ),  # 1
    (2, TType.STRUCT, 'image', [ImageInfo, None], None, ),  # 2
    (3, TType.STRUCT, 'imageMark', [ImageInfo, None], None, ),  # 3
)
all_structs.append(TaskInfo)
TaskInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'taskId', 'UTF8', None, ),  # 1
    (2, TType.I32, 'state', None, None, ),  # 2
    (3, TType.I32, 'result', None, None, ),  # 3
    (4, TType.STRUCT, 'info', [HolesRecgInfo, None], None, ),  # 4
)
all_structs.append(DeviceInfo)
DeviceInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'runningState', None, None, ),  # 1
)
fix_spec(all_structs)
del all_structs
